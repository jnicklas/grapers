use core::*;
use core::schema::*;
use super::OperationType;
use definition::Definition;
use document::Document;
use tok::{self, Tok};

grammar<'input>(text: &'input str)["LALR(1)"];

pub Document: Document = {
    <definitions:(Definition)+> => Document { definitions: definitions }
};

Definition: Definition = {
    OperationDefinition,
    // FragmentDefinition
    TypeSystemDefinition,
};

OperationDefinition: Definition = {
    <operation:OperationType> <fields:SelectionSet> => {
        match operation {
            OperationType::Query => Definition::Query(query::Query::new(fields)),
            _ => panic!("mutation is not yet supported"),
        }
    }
};

SelectionSet: Vec<query::Field> = {
    "{" <fields:(Field)*> "}" => { fields }
};

Field: query::Field = {
    <alias:(Alias)?> <name:FieldName> <arguments:(Arguments)?> <fields:(SelectionSet)?> => {
        query::Field::new(name, alias, arguments.unwrap_or(Vec::new()), fields.map(|f| query::Query::new(f)))
    }
};

Arguments: Vec<query::Argument> = {
    "(" <arguments:(Argument)*> ")" => { arguments }
};

Argument: query::Argument = {
    <name:FieldName> ":" <value:Value> => { query::Argument::new(name, value) }
};

Alias: FieldName = {
    <alias:FieldName> ":" => alias
};

Value: query::Value = {
    <value:"String"> => query::Value::String(value.into())
    // ConstVariable
    // IntValue
    // FloatValue
    // BooleanValue
    // EnumValue
    // ListValueConst
    // ObjectValueConst
};

TypeSystemDefinition: Definition = {
    SchemaDefinition,
    TypeDefinition
    // TypeExtensionDefinition
    // DirectiveDefinition
};

SchemaDefinition: Definition = {
    "schema" "{" <operations:(OperationTypeDefinition)+> "}" => {
      let mut query = Vec::new();

      for (operation, name) in operations {
        match operation {
          OperationType::Query => query.push(name),
          _ => (),
        }
      }

      if query.len() > 1 {
        panic!("schema must not contain more than one query definition");
      }

      Definition::Schema(Schema::new(query.pop(), None))
    }
};

OperationTypeDefinition: (OperationType, TypeName) = {
    <operation:OperationType> ":" <name:TypeName> => { (operation, name) }
};

OperationType: OperationType = {
    "query" => { OperationType::Query },
    "mutation" => { OperationType::Mutation },
};

Type: Type = {
    <type_name:TypeName> => {
        match type_name.as_str() {
            "Int" => Type::Int,
            "Float" => Type::Float,
            "String" => Type::String,
            "Boolean" => Type::Boolean,
            "Id" => Type::Id,
            _ => Type::NamedType(type_name)
        }
    },
    "[" <ty:Type> "]" => { Type::List(Box::new(ty)) },
    <ty:Type> "!" => { Type::NonNull(Box::new(ty)) }
};

TypeName: TypeName = {
    <name:Identifier> => { TypeName(name.to_string()) }
};

FieldName: FieldName = {
    <name:Identifier> => { FieldName(name.to_string()) }
};

Identifier: &'input str = {
    "schema" => { "schema" },
    "query" => { "query" },
    "mutation" => { "mutation" },
    "type" => { "type" },
    "implements" => { "implements" },
    "on" => { "on" },
    <value:"identifier"> => { value },
};

TypeDefinition: Definition = {
//     ScalarTypeDefinition
    ObjectTypeDefinition
//     InterfaceTypeDefinition
//     UnionTypeDefinition
//     EnumTypeDefinition
//     InputObjectTypeDefinition
};

ObjectTypeDefinition: Definition = {
    "type" <name:TypeName> <interfaces:(ImplementsInterfaces)?> "{" <fields:(FieldDefinition)+> "}" => {
        Definition::Object(Object::new(name, fields, interfaces.unwrap_or_else(|| Vec::new())))
    }
};

ImplementsInterfaces: Vec<TypeName> = {
    "implements" <types:(TypeName)+> => { types }
};

FieldDefinition: Field = {
    <name:FieldName> <args:(FieldArguments)?> ":" <ty:Type> => {
        Field::new(name, ty, args.unwrap_or(Vec::new()))
    }
};

FieldArguments: Vec<Argument> = {
    "(" <args:(FieldArgument)*> ")" => { args }
};

FieldArgument: Argument = {
    <name:FieldName> ":" <ty:Type> => { Argument::new(name, ty) }
};

extern {
    type Location = usize;
    type Error = tok::Error;
    enum Tok<'input> {
        "schema" => Tok::Schema,
        "query" => Tok::Query,
        "mutation" => Tok::Mutation,
        "type" => Tok::Type,
        "on" => Tok::On,
        "implements" => Tok::Implements,
        "identifier" => Tok::Identifier(<&'input str>),
        "String" => Tok::StringValue(<&'input str>),

        "!" => Tok::Dollar,
        "$" => Tok::Bang,
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        ":" => Tok::Colon,
        "=" => Tok::Equals,
        "@" => Tok::At,
        "[" => Tok::LBracket,
        "]" => Tok::RBracket,
        "{" => Tok::LBrace,
        "|" => Tok::Pipe,
        "}" => Tok::RBrace,
    }
}
