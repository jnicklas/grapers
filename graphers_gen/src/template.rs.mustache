extern crate graphers_core;
extern crate serde;

use std::any::Any as StdAny;
use std::any::TypeId;
use std::borrow::Cow;
use std::mem::transmute;
use serde::{Serialize, Serializer};
use serde::ser::{MapVisitor};
use self::graphers_core::*;

{{#query_root}}
pub struct QueryResult<'a, T>({{name}}Selection<'a, T>) where T: 'a + Resolve{{name}};
{{/query_root}}

////////////////////////////////////////////////////////////////////////////////
// RESOLVE TRAITS
// Implement these in your own code to resolve the fields in a query
////////////////////////////////////////////////////////////////////////////////

pub trait Schema: 'static {
    {{#objects}}
    type {{name}}: Resolve{{name}};
    {{/objects}}

    {{#query_root}}
    fn query<'a>(&self, query: &'a query::Query) -> QueryResult<'a, Self::{{name}}> {
        QueryResult({{name}}Selection { target: self.root(), selection_set: query.selection_set() })
    }

    fn root(&self) -> Self::{{name}};
    {{/query_root}}
}

pub trait HasSchema {
    type Schema: Schema;
}

{{#objects}}
pub trait Resolve{{name}}: HasSchema + {{{implemented_interfaces}}} {
    {{#fields}}
    fn {{name}}(&self, {{{parameters}}}) -> {{{ty}}};
    {{/fields}}
}

{{/objects}}

////////////////////////////////////////////////////////////////////////////////
// INTERFACES
// GraphQL interfaces which can be implemented by other types
////////////////////////////////////////////////////////////////////////////////

{{#interfaces}}
pub trait {{name}}: Any + HasSchema {
    {{#fields}}
    fn {{name}}(&self, {{{parameters}}}) -> {{{ty}}};
    {{/fields}}
}

impl<S> {{name}}<Schema=S> where S: Schema {
    pub fn is<T: {{name}}>(&self) -> bool {
        TypeId::of::<T>() == Any::get_type_id(self)
    }

    pub fn downcast_ref<T: {{name}}>(&self) -> Option<&T> {
        if self.is::<T>() {
            unsafe {
                let trait_object: TraitObject = transmute(self);
                Some(transmute(trait_object.data))
            }
        } else {
            None
        }
    }
}

{{/interfaces}}

////////////////////////////////////////////////////////////////////////////////
// PLUMBING
// Everything after this line is plumbing machinery, you can ignore it
////////////////////////////////////////////////////////////////////////////////

pub trait Any: StdAny {
    /// Gets the `TypeId` of `self`.
    #[doc(hidden)]
    fn get_type_id(&self) -> TypeId;
}

impl<T: StdAny> Any for T {
    fn get_type_id(&self) -> TypeId { TypeId::of::<T>() }
}

pub struct TraitObject {
    pub data: *mut (),
    pub vtable: *mut (),
}

{{#query_root}}
impl<'a, T> Serialize for QueryResult<'a, T> where T: 'a + Resolve{{name}} {
    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error> where S: Serializer {
        self.0.serialize(serializer)
    }
}
{{/query_root}}

{{#objects}}
struct {{name}}Selection<'a, T> where T: 'a + Resolve{{name}} {
    target: T,
    selection_set: &'a [query::Selection],
}

impl<'a, T> Serialize for {{name}}Selection<'a, T> where T: 'a + Resolve{{name}} {
    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error> where S: Serializer {
        serializer.serialize_map({{name}}StructVisitor {
            target: &self.target,
            iter: self.selection_set.iter(),
        })
    }
}

struct {{name}}StructVisitor<'a, T, I> where T: 'a + Resolve{{name}}, I: Iterator<Item=&'a query::Selection> {
    target: &'a T,
    iter: I,
}

impl<'a, T, I> MapVisitor for {{name}}StructVisitor<'a, T, I> where T: 'a + Resolve{{name}}, I: Iterator<Item=&'a query::Selection> {
    fn visit<S>(&mut self, serializer: &mut S) -> Result<Option<()>, S::Error> where S: Serializer {
        match self.iter.next() {
            Some(&query::Selection::Field(ref field)) => {
                match field.name().as_str() {
                    {{#fields}}
                    "{{name}}" => {
                        let target = Resolve{{object_name}}::{{name}}(self.target, {{{arguments}}});
                        {{{preserialize}}}
                        Ok(Some(try!(serializer.serialize_map_elt(&field.alias().as_str(), target))))
                    },
                    {{/fields}}
                    name => panic!("unknown field {}", name),
                }
            },
            Some(&query::Selection::FragmentSpread(_)) => {
                panic!("not implemented!");
            },
            Some(&query::Selection::InlineFragment(_)) => {
                panic!("not implemented!");
            },
            None => Ok(None)
        }
    }
}

{{/objects}}

{{#interfaces}}
struct {{name}}Selection<'a, T> where T: 'a + Schema {
    target: Box<{{name}}<Schema=T>>,
    selection_set: &'a [query::Selection],
}

impl<'a, T> Serialize for {{name}}Selection<'a, T> where T: 'a + Schema {
    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error> where S: Serializer {
        serializer.serialize_map({{name}}StructVisitor {
            target: &*self.target,
            iter: self.selection_set.iter(),
        })
    }
}

struct {{name}}StructVisitor<'a, T, I> where T: 'a + Schema, I: Iterator<Item=&'a query::Selection> {
    target: &'a {{name}}<Schema=T>,
    iter: I,
}

impl<'a, T, I> MapVisitor for {{name}}StructVisitor<'a, T, I> where T: 'a + Schema, I: Iterator<Item=&'a query::Selection> {
    fn visit<S>(&mut self, serializer: &mut S) -> Result<Option<()>, S::Error> where S: Serializer {
        match self.iter.next() {
            Some(&query::Selection::Field(ref field)) => {
                match field.name().as_str() {
                    {{#fields}}
                    "{{name}}" => {
                        let target = self.target.{{name}}({{{arguments}}});
                        {{{preserialize}}}
                        Ok(Some(try!(serializer.serialize_map_elt(&field.alias().as_str(), target))))
                    },
                    {{/fields}}
                    name => panic!("unknown field {}", name),
                }
            },
            Some(&query::Selection::FragmentSpread(_)) => {
                panic!("not implemented!");
            },
            Some(&query::Selection::InlineFragment(ref fragment)) => {
                match fragment.on().as_str() {
                    {{#implementors}}
                    "{{name}}" => {
                        if let Some(target) = self.target.downcast_ref::<T::{{name}}>() {
                            let iter = fragment.selection_set().iter();
                            let mut visitor = {{name}}StructVisitor { target: target, iter: iter };
                            while let Some(_) = try!(MapVisitor::visit(&mut visitor, serializer)) {};
                        }
                    }
                    {{/implementors}}
                    other => panic!("unknown fragment type: {}", other),
                }
                Ok(Some(()))
            },
            None => Ok(None)
        }
    }
}

{{/interfaces}}
